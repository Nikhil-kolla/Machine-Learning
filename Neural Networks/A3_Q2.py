# -*- coding: utf-8 -*-
"""A3_Q2(final).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FozLaeKtGk7XW64y8uar1nt1RgsWpvB8

**A3_Q2**
"""

from sklearn import svm
from sklearn.decomposition import PCA
from sklearn.metrics import accuracy_score
from sklearn.metrics import roc_curve,auc
from sklearn import metrics
from sklearn.metrics import confusion_matrix
import torch
import pickle
import torchvision
import torchvision.models as models
import matplotlib.pyplot as plt
from torch.autograd import Variable
import time

"""import torchvision.transforms.functional as F"""

#https://pytorch.org/docs/stable/_modules/torchvision/models/alexnet.html
import torchvision.transforms as transforms
import torch.nn as nn
import pprint
from PIL import Image
from sklearn.feature_selection import SelectFromModel
import numpy as np

pkl_file = open('train_CIFAR.pickle', 'rb')
pkl_file1 = open('test_CIFAR.pickle', 'rb')

data_train = pickle.load(pkl_file)
data_test = pickle.load(pkl_file1)

X_train=data_train["X"]
y_train = data_train["Y"]

X_test=data_test["X"]
y_test=data_test["Y"]

print(X_train.shape)
print(y_train.shape)
print(X_test.shape)
print(y_test.shape)

X_train = X_train.reshape(10000,3,32,32).transpose(0,2,3,1)
print(X_train.shape)
X_test = X_test.reshape(2000,3,32,32).transpose(0,2,3,1)
print(X_test.shape)

alex = models.alexnet(pretrained=True)

transform = transforms.Compose([
    transforms.Resize((227, 4096)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

def get_vector(image):
    t_img = Variable(transform(image)).unsqueeze(0)
    output = alex.classifier[6](t_img).detach().numpy().ravel()
    return output

image = []
for i in range(100):
    image.append(Image.fromarray(np.uint8(X_train[i])))

feature_train = []
for i in range(len(image)):
    feature_train.append((get_vector(image[i])))

yy = []
for i in range(100):
    yy.append(y_train[i])

test_images = []
for i in range(100):
    test_images.append(Image.fromarray(np.uint8(X_test[i])))

features_test = []
for i in range(len(test_images)):
    features_test.append((get_vector(test_images[i])))

y_test_ground = []
for i in range(100):
    y_test_ground.append(y_test[i])

inn = time.time()
clf = svm.SVC(kernel ='linear', probability=True)
clf.fit(feature_train, yy)
out = time.time()
print("Time taken by model: ",(out-inn))

y_cap = clf.predict(features_test)
scores = clf.predict_proba(features_test)

print(accuracy_score(y_test_ground,y_cap))

false_positive_rate, true_positive_rate, thres = metrics.roc_curve(y_test_ground, y_cap, pos_label=2)
true_positive_rate=[0]*true_positive_rate

roc_curve=auc(false_positive_rate,true_positive_rate)

confusion_matrix(y_test_ground, y_cap)

#https://machinelearningmastery.com/roc-curves-and-precision-recall-curves-for-classification-in-python/
def draw_roc(y_actual, scores, title=''):
    fpr, tpr, thresholds = roc_curve(y_actual, scores, pos_label=1)
    auroc_value = auc(fpr, tpr)

    plt.plot(fpr,tpr, label = 'AUC: '+str(round(auroc_value, 4)))
    plt.plot([0,1],[0,1],'k--')
    plt.xlabel('FPR = 1-Specificity')
    plt.ylabel("TPR = Recall = Sensitivity")
    plt.title("AUC-ROC Curve: " + title)
    plt.legend(loc = 'lower right')
    plt.savefig(title+'-ROC')
    return auroc_value

draw_roc(y_test_ground,scores[:,1])

